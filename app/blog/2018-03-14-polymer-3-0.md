---
title:  "Draft Outline for next blog post for Polymer 3.0 preview"
---

Polymer 3.0 latest preview is available, enthusiastic intro text! we changed some things, here's a summary:

  * [Bare module specifiers](#baremodules)
  * [Renamed some stuff](#renamedstuff)
  * [State of dynamic imports?](#dynamicimports)
  * [Tools?](#toolschanges)

## Bare module specifiers {#baremodules}

From now on, default is to use bare module specifiers instead of whole path names, meaning build tools will automatically resolve and rewrite paths

* Benefits of this change
  * npm ecosystem works this way
  * Easier to move your dependencies around
  * Reusable elements and apps can use same import statement now? previously you had to do `./node_modules/@polymer/...` for apps and `../@polymer/...` for reusable elements

* What you need to do

  * You don't need to do anything if you're converting a 2.0 proj - modulizer will do it for you
  * If you are updating previous Polymer 3.0 preview code, make the changes below
  * Write future code with the syntax below
  

* If you want to disable it

  In polymer.json, add

  ```json
  "moduleResolution": "none"
  ```
  
  See [polymer.json spec](/{{{polymer_version_dir}}}/docs/tools/polymer-json) for more info

possible questions
  * Can I still use paths? (yes, use `"moduleResolution": "none"`)
  * what happens if I mix paths and bare module specifiers?
  * If `polymer serve` serves unbuilt non-web-friendly code how does this work, does the server do its own path resolution or..? where exactly does path resolution occur?
  * Other tools changes that are specific to bare module specifiers?
  * Other impacts?

### Write code using bare module imports

To import the Polymer library:

```js
import { PolymerElement } from '@polymer/polymer/polymer-element';
```

To import an element from the Polymer library helper elements:

```js
import '@polymer/polymer/lib/elements/dom-if';
```

To import a Polymer Element:

```js
import '@polymer/paper-thing/paper-thing';
```

To import a behavior:

```js
import {IronResizableBehavior}
    from "@polymer/iron-resizable-behavior/iron-resizable-behavior"
```

To import utility modules like `Async` that export several members, you can import individual members, or import the entire module:

```js
import * as Async from "@polymer/polymer/lib/utils/async"

Async.microTask.run(callback);
```

Refer to API docs to see what each thing exports

#### Example

##### Old Polymer 3.0 preview syntax

my-thing.js

```js
// old syntax uses full path names
import { Element as PolymerElement } from './node_modules/@polymer/polymer/polymer-element.js';
import './node_modules/@polymer/polymer/lib/elements/dom-if.js';
import './node_modules/@polymer/paper-checkbox/paper-checkbox.js';

class MyThing extends PolymerElement {
  static get template () {
    // old syntax let you return a string literal
    return `
      <h1>Hello World</h1>
      <template is="dom-if" if="true">
        <paper-checkbox>I like pie</paper-checkbox>
      </template>
    `;
  }
}

customElements.define('my-thing', MyThing);
```

index.html

```html
<!-- this doesn't change -->
<script src="path to polyfill">
<script type="module" src="./my-thing.js">
<my-thing></my-thing>
```

##### Current Polymer 3.0 preview syntax

my-thing.js

```js
//import statements now use bare module specifiers
import { PolymerElement, html } from '@polymer/polymer/polymer-element';
import '@polymer/polymer/lib/elements/dom-if';
import '@polymer/paper-checkbox/paper-checkbox';

class MyThing extends PolymerElement {
  static get template (){
    // always return an HTMLTemplateElement not a string literal
    return html`
      <h1>Hello World</h1>
      <template is="dom-if" if="true">
        <paper-checkbox>I like pie</paper-checkbox>
      </template>
    `;
  }
} 

customElements.define('my-thing', MyThing);
```

index.html

```html
<!-- this doesn't change -->
<script src="path to polyfill">
<script type="module" src="./my-thing.js">
<my-thing></my-thing>
```

## Renamed stuff 

* `Element` renamed to `PolymerElement`?
* ?

## Dynamic imports

* Specification for dynamic imports using the `import()` operator 
* Has it landed?
* The import operator acts like a function, and returns a `Promise`:

```js
import('my-view1.js').then((MyView1) => {
  console.log("MyView1 loaded");
}).catch((reason) => {
  console.log("MyView1 failed to load", reason);
});
```

* Do Polymer CLI tools support transforming dynamic imports yet?
* Can use PRPL/lazy-loading?

## Tools

* Changes to defaults
* New polymer.json properties
* `polymer init` template/s for 3.x?


## Samples

#### Sample App

[Insert github link](https://github.com/).

#### Sample reusable element

[Insert github link](https://github.com/).